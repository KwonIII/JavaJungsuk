쓰레드
프로세스와 쓰레드(process&thread)
>프로세스: 실행 중인 프로그램, 자원(resource)과 쓰레드로 구성
>쓰레드: 프로세스 내에서 실제 작업을 수행
		모든 프로세스는 최소한 하나의 쓰레드를 가지고 있다.
		프로세스:쓰레드 = 공장:일꾼
>싱글 쓰레드 프로세스=자원+쓰레드			>멀티 쓰레드 프로세스=자원+쓰레드+쓰레드+쓰레드...

*하나의 새로운 프로세스를 생성한느 것보다 하나의 새로운 쓰레드를 생성하는 것이 더 적은 비용이 든다.

멀티쓰레드의 장단점
장점
-시스템 자원을 보다 효율적으로 사용
-사용자에 대한 응답성이 향상
-작업이 분리되어 코드가 간결
단점
-동기화에 주의해야 한다
-교착상태(dead-lock)가 발생하지 않도록 주의해야 한다.
-각 쓰레드가 효율적으로 고르게 실행될 수 있게 해야 한다.
->프로그래밍할 때 고려해야 할 사항들이 많다.

쓰레드의 구현과 실행
1.Thread클래스를 상속
class MyThread extends Thread{
	public void run(){
		//Thread클래스의 run()을 오버라이딩
	}
}
2.Runnable인터페이스를 구현
class MyThread2 implements Runnable{
	public void run(){
		//Runnable인터페이스의 추상메서드 run()을 구현
	}
}

쓰레드의 실행 - start()
-쓰레드를 생성한 후에 start()를 호출해야 쓰레드가 작업시작

main쓰레드
-main메서드의 코드를 수행하는 쓰레드
-쓰레드는 사용자쓰레드와 데몬쓰레드(보조쓰레드) 두종류가 있다.
실행중인 사용자 쓰레드가 하나도 없을 때 프로그램은 종료된다.

sleep()
-현재 쓰레드를 지정된 시간동안 멈추게 한다.
-예외 처리를 해야 한다.(InterruptedException이 발샏하면 깨어남)
-특정 쓰레드를 지정해서 멈추게 하는 것은 불가능하다.

suspend(), resume(), stop()
-쓰레드의 실행을 일시정지, 재개, 완전정지 시킨다.
-suspend(), resume(), stop()은 교착상태에 빠지기 쉬워서 deprecated되었다.

join()
-지정된 시간동안 특정 쓰레드가 작업하는 것을 기다린다.
-예외처리를 해야 한다.(InterruptedException이 발생하면 작업 재개)

yield()
-남은 시간을 다음 쓰레드에게 양보하고, 자신(현재 쓰레드)은 실행대기한다.
-yield()와 interrupt()를 적절히 사용하면, 응답성과 효율성을 높일 수 있다.

쓰레드의 동기화(synchronization)
-멀티 쓰레드 프로세스에서는 다른 쓰레드의 작업에 영향을 미칠 수 있다.
-진행중인 작업이 다른 쓰레드에게 간섭받지 않게 하려면 '동기화'가 필요
동기화: 한 쓰레드가 진행중인 작업을 다른 쓰레드가 간섭하지 못하게 막는 것
-동기화하려면 간섭받지 않아야 하는 문장들을 '임계영영'으로 설정
-임계영역은 락(lock)을 얻은 단 하나의 쓰레드만 출입가능(객체1개에 락1개)

synchronized를 이용한 동기화
-synchronized로 임계영역(lock이 걸리는 영역)을 설정하는 방법 2가지
1.메서드 전체를 임계영역으로 지정
public synchronized void calcSum(){
	//....
}
2.특정한 영역을 임계 영역으로 지정
synchronized(객체의 참조변수){
	//....
}
wait()과 notify()
-동기화의 효율을 높이기 위해 wait(), notify()를 사용.
-Object클래스에 정의되어 있으며, 동기화 블록 내에서만 사용할 수 있다.
*wait()-객체의 lock을 풀고 쓰레드를 해당 객체의 waiting pool에 넣는다.
*notify()-waiting pool에서 대기중인 쓰레드 중의 하나를 깨운다.
*notifyAll()-waiting pool에서 대기중인 모든 쓰레드를 깨운다.
